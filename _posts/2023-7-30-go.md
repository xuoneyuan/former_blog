---
layout:     post
title:      8小时转职Golang工程师
subtitle:   HERE WE GO!
date:       2023-7-30
author:     刘丹冰
header-img: 
catalog: true
tags:
    - Golang
---

## 一、引言
### 课程提纲
![1]({{site.baseurl}}/img-post/go-1.png)
### Golang生态拓展介绍“站在巨人的肩膀上”
#### Web框架
- beego
- gin
- echo
- lris
#### 微服务框架
- go kit
- lstio
#### 容器编排
- Kubernetes
- swarm
#### 服务发现
- consul
- etcd
#### 存储引擎
- tidb
#### 静态建站
- hugo
#### 中间件
- 消息队列 nsq
- Tcp长链接框架（轻量级服务器） zinx
- Leaf(游戏服务器）
- RPC框架 gPRC
- redis集群 codis
#### 爬虫框架
- go query
## 二、Golang开发环境
### 下载
Go官方镜像站（推荐）：https://golang.google.cn/dl/
### 环境配置

### 开发工具
- vscode
- Goland
## 三、Golang语言特性
### Golang的优势
![1]({{site.baseurl}}/img-post/g-2.png)
![1]({{site.baseurl}}/img-post/g-3.png)


![1]({{site.baseurl}}/img-post/g-4.png)

~~~
package main
  
import (
    "fmt"
    "time"
)

func goFunc(i int) {
    fmt.Println("goroutine ", i, " ...")
}

func main() {
    for i := 0; i < 10000; i++ {
        go goFunc(i) //开启一个并发协程
    }

    time.Sleep(time.Second)
}
~~~

![1]({{site.baseurl}}/img-post/g-5.png)

![1]({{site.baseurl}}/img-post/g-6.png)

![1]({{site.baseurl}}/img-post/g-7.png)

![1]({{site.baseurl}}/img-post/g-8.png)

### Golang适合做什么
1. 云计算基础设施领域
代表项目：docker、kubernetes、etcd、consul、cloudflare CDN、七牛云存储等。
2. 基础后端软件
代表项目：tidb、influxdb、cockroachdb等。
3. 微服务
代表项目：go-kit、micro、monzo bank的typhon、bilibili等。
4. 互联网基础设施
代表项目：以太坊、hyperledger等。
### Golang明星作品
![1]({{site.baseurl}}/img-post/g-9.png)

![1]({{site.baseurl}}/img-post/g-10.png)

### Golang的不足
- 包管理，大部分包都在github上
- 所有Excepiton都用Error来处理
- 对C的降级处理，并非无缝，没有C降级到asm那么完美(序列化问题)
## 四、Golang语法新奇
### 从一个main函数初见golang语法

~~~go
  package main


  import "fmt"


  func main() {
          /* 简单的程序 万能的hello world */
          fmt.Println("Hello Go")
  }
~~~

- 第一行代码package main定义了包名。你必须在源文件中非注释的第一行指明这个文件属于哪个包，如：package main。package main表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。
- 下一行import "fmt"告诉 Go 编译器这个程序需要使用 fmt 包（的函数，或其他元素），fmt 包实现了格式化 IO（输入/输出）的函数。
- 下一行func main()是程序开始执行的函数。main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 init() 函数则会先执行该函数）。
注意：这里面go语言的语法，定义函数的时候，‘{’ 必须和函数名在同一行，不能另起一行。
- 下一行 /.../ 是注释，在程序执行时将被忽略。单行注释是最常见的注释形式，你可以在任何地方使用以 // 开头的单行注释。多行注释也叫块注释，均已以 / 开头，并以 / 结尾，且不可以嵌套使用，多行注释一般用于包的文档描述或注释成块的代码片段。
- 下一行fmt.Println(...)可以将字符串输出到控制台，并在最后自动增加换行字符 \n。 使用 fmt.Print("hello, world\n") 可以得到相同的结果。 Print 和 Println 这两个函数也支持使用变量，如：fmt.Println(arr)。如果没有特别指定，它们会以默认的打印格式将变量 arr 输出到控制台。
### 变量的声明
声明变量的一般形式是使用 var 关键字
#### 变量声明
第一种，指定变量类型，声明后若不赋值，使用默认值0。

~~~go
var v_name v_type
v_name = value
package main


import "fmt"


func main() {
        var a int
        fmt.Printf(" = %d\n", a)
}


$go run test.go
a = 0
~~~
第二种，根据值自行判定变量类型。
~~~go
var v_name = value
~~~

第三种，省略var, 注意 :=左侧的变量不应该是已经声明过的，否则会导致编译错误
~~~go
v_name := value


// 例如
var a int = 10
var b = 10
c : = 10
~~~

eg
~~~go
package main


import "fmt"


func main() {
        //第一种 使用默认值
        var a int
        fmt.Printf("a = %d\n", a)


        //第二种
        var b int = 10
        fmt.Printf("b = %d\n", b)


        //第三种 省略后面的数据类型,自动匹配类型
        var c = 20
        fmt.Printf("c = %d\n", c)


        //第四种 省略var关键字
        d := 3.14
        fmt.Printf("d = %f\n", d)
}
~~~
#### 多变量声明
~~~go
package main


import "fmt"


var x, y int
var ( //这种分解的写法,一般用于声明全局变量
        a int
        b bool
)


var c, d int = 1, 2
var e, f = 123, "liudanbing"


//这种不带声明格式的只能在函数体内声明
//g, h := 123, "需要在func函数体内实现"


func main() {
        g, h := 123, "需要在func函数体内实现"
        fmt.Println(x, y, a, b, c, d, e, f, g, h)


        //不能对g变量再次做初始化声明
        //g := 400


        _, value := 7, 5  //实际上7的赋值被废弃，变量 _  不具备读特性
        //fmt.Println(_) //_变量的是读不出来的
        fmt.Println(value) //5
}
~~~

### 常量
常量是一个简单值的标识符，在程序运行时，不会被修改的量。

常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。

常量的定义格式：
~~~go
const identifier [type] = value
~~~
你可以省略类型说明符 [type]，因为编译器可以根据变量的值来推断其类型。
显式类型定义：
~~~go
const b string = "abc"
~~~
隐式类型定义：
~~~go
const b = "abc"
~~~
eg:
~~~go
package main


import "fmt"


func main() {
   const LENGTH int = 10
   const WIDTH int = 5   
   var area int
   const a, b, c = 1, false, "str" //多重赋值


   area = LENGTH * WIDTH
   fmt.Printf("面积为:\n", area)
   println(a, b, c)   
}
~~~
常量还可以用作枚举：
~~~go
const (
    Unknown = 0
    Female = 1
    Male = 2
)
~~~
数字 0、1 和 2 分别代表未知性别、女性和男性。

常量可以用len(), cap(), unsafe.Sizeof()常量计算表达式的值。常量表达式中，函数必须是内置函数，否则编译不过：
~~~go
package main


import "unsafe"
const (
    a = "abc"
    b = len(a)
    c = unsafe.Sizeof(a)
)


func main(){
    println(a, b, c)
}
~~~
输出结果为：abc, 3, 16

unsafe.Sizeof(a)输出的结果是16 。
 
字符串类型在 go 里是个结构, 包含指向底层数组的指针和长度,这两部分每部分都是 8 个字节，所以字符串类型大小为 16 个字节。
#### 优雅的常量 iota
有些概念有名字，并且有时候我们关注这些名字，甚至（特别）是在我们代码中。
~~~go
const (
    CCVisa            = "Visa"
    CCMasterCard      = "MasterCard"
    CCAmericanExpress = "American Express"
)
~~~

在其他时候，我们仅仅关注能把一个东西与其他的做区分。有些时候，有些时候一件事没有本质上的意义。比如，我们在一个数据库表中存储产品，我们可能不想以 string 存储他们的分类。我们不关注这个分类是怎样命名的，此外，该名字在市场上一直在变化。

我们仅仅关注它们是怎么彼此区分的。
~~~go
const (
    CategoryBooks    = 0
    CategoryHealth   = 1
    CategoryClothing = 2
)
~~~
使用 0, 1, 和 2 代替，我们也可以选择 17， 43， 和 61。这些值是任意的。

在 Go，常量有许多微妙之处。当用好了，可以使得代码非常优雅且易维护的。
#### 自增长
在 golang 中，一个方便的习惯就是使用iota标示符，它简化了常量用于增长数字的定义，给以上相同的值以准确的分类。
~~~go
const (
    CategoryBooks = iota // 0
    CategoryHealth       // 1
    CategoryClothing     // 2
)
~~~
#### iota和表达式
iota可以做更多事情，而不仅仅是 increment。更精确地说，iota总是用于 increment，但是它可以用于表达式，在常量中的存储结果值。
~~~go
type Allergen int


const (
    IgEggs Allergen = 1 << iota         // 1 << 0 which is 00000001
    IgChocolate                         // 1 << 1 which is 00000010
    IgNuts                              // 1 << 2 which is 00000100
    IgStrawberries                      // 1 << 3 which is 00001000
    IgShellfish                         // 1 << 4 which is 00010000
)
~~~
这个工作是因为当你在一个const组中仅仅有一个标示符在一行的时候，它将使用增长的iota取得前面的表达式并且再运用它，。在 Go 语言的spec中， 这就是所谓的隐性重复最后一个非空的表达式列表.

如果你对鸡蛋，巧克力和海鲜过敏，把这些 bits 翻转到 “on” 的位置（从左到右映射 bits）。然后你将得到一个 bit 值00010011，它对应十进制的 19。
~~~go
fmt.Println(IgEggs | IgChocolate | IgShellfish)


// output:
// 19
type ByteSize float64


const (
    _           = iota                   // ignore first value by assigning to blank identifier
    KB ByteSize = 1 << (10 * iota)       // 1 << (10*1)
    MB                                   // 1 << (10*2)
    GB                                   // 1 << (10*3)
    TB                                   // 1 << (10*4)
    PB                                   // 1 << (10*5)
    EB                                   // 1 << (10*6)
    ZB                                   // 1 << (10*7)
    YB                                   // 1 << (10*8)
)
~~~
当你在把两个常量定义在一行的时候会发生什么？

Banana 的值是什么？ 2 还是 3？ Durian 的值又是？
~~~go
const (
    Apple, Banana = iota + 1, iota + 2
    Cherimoya, Durian
    Elderberry, Fig
)
~~~
在下一行增长，而不是立即取得它的引用。
~~~go
// Apple: 1
// Banana: 2
// Cherimoya: 2
// Durian: 3
// Elderberry: 3
// Fig: 4
~~~
### 函数
#### 函数返回多个值
Go 函数可以返回多个值，例如：
~~~go
package main


import "fmt"


func swap(x, y string) (string, string) {
   return y, x
}


func main() {
   a, b := swap("Mahesh", "Kumar")
   fmt.Println(a, b)
}
~~~
#### init函数与import
首先我们看一个例子：init函数：

init 函数可在package main中，可在其他package中，可在同一个package中出现多次。

main函数

main 函数只能在package main中。

执行顺序

golang里面有两个保留的函数：init函数（能够应用于所有的package）和main函数（只能应用于package main）。这两个函数在定义时不能有任何的参数和返回值。

虽然一个package里面可以写任意多个init函数，但这无论是对于可读性还是以后的可维护性来说，我们都强烈建议用户在一个package中每个文件只写一个init函数。

go程序会自动调用init()和main()，所以你不需要在任何地方调用这两个函数。每个package中的init函数都是可选的，但package main就必须包含一个main函数。

程序的初始化和执行都起始于main包。

如果main包还导入了其它的包，那么就会在编译时将它们依次导入。有时一个包会被多个包同时导入，那么它只会被导入一次（例如很多包可能都会用到fmt包，但它只会被导入一次，因为没有必要导入多次）。

当一个包被导入时，如果该包还导入了其它的包，那么会先将其它包导入进来，然后再对这些包中的包级常量和变量进行初始化，接着执行init函数（如果有的话），依次类推。

等所有被导入的包都加载完毕了，就会开始对main包中的包级常量和变量进行初始化，然后执行main包中的init函数（如果存在的话），最后执行main函数。下图详细地解释了整个执行过程：

![1]({{site.baseurl}}/img-post/g-11.png)

首先我们看一个例子：

Lib1.go
~~~go
package InitLib1

import "fmt"

func init() {
    fmt.Println("lib1")
}
~~~
Lib2.go
~~~go
package InitLib2

import "fmt"

func init() {
    fmt.Println("lib2")
}
~~~
main.go
~~~go
package main

import (
    "fmt"
    _ "GolangTraining/InitLib1"
    _ "GolangTraining/InitLib2"
)

func init() {
    fmt.Println("libmain init")
}

func main() {
    fmt.Println("libmian main")
}
~~~
代码很简单，只是一些简单的输出
![1]({{site.baseurl}}/img-post/g-12.png)
输出的顺序与我们上面图给出的顺序是一致的

那我们现在就改动一个地方，Lib1包导入Lib2，main包不管
~~~go
package InitLib1

import (
    "fmt"
    _ "GolangTraining/InitLib2"
)

func init() {
    fmt.Println("lib1")
}
~~~
输出:
~~~
lib2
lib1
libmain init
libmian main
~~~
main包以及Lib1包都导入了Lib2，但是只出现一次，并且最先输出，

说明如果一个包会被多个包同时导入，那么它只会被导入一次，而先输出lib2是因为main包中导入Lib1时，Lib1又导入了Lib2，会首先初始化Lib2包的东西
#### 函数参数
函数如果使用参数，该变量可称为函数的形参。

形参就像定义在函数体内的局部变量。

调用函数，可以通过两种方式来传递参数：

##### 值传递
值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。

默认情况下，Go 语言使用的是值传递，即在调用过程中不会影响到实际参数。

以下定义了 swap() 函数：
~~~go
/* 定义相互交换值的函数 */
func swap(x, y int) int {
   var temp int


   temp = x /* 保存 x 的值 */
   x = y    /* 将 y 值赋给 x */
   y = temp /* 将 temp 值赋给 y*/


   return temp;
}
~~~
接下来，让我们使用值传递来调用 swap() 函数：
~~~go
package main


import "fmt"


func main() {
   /* 定义局部变量 */
   var a int = 100
   var b int = 200


   fmt.Printf("交换前 a 的值为 : %d\n", a )
   fmt.Printf("交换前 b 的值为 : %d\n", b )


   /* 通过调用函数来交换值 */
   swap(a, b)


   fmt.Printf("交换后 a 的值 : %d\n", a )
   fmt.Printf("交换后 b 的值 : %d\n", b )
}


/* 定义相互交换值的函数 */
func swap(x, y int) int {
   var temp int


   temp = x /* 保存 x 的值 */
   x = y    /* 将 y 值赋给 x */
   y = temp /* 将 temp 值赋给 y*/


   return temp;
}
~~~
以下代码执行结果为：\
交换前 a 的值为 : 100\
交换前 b 的值为 : 200\
交换后 a 的值 : 100\
交换后 b 的值 : 200
##### 引用传递(指针传递)
Go 语言中指针是很容易学习的，Go 语言中使用指针可以更简单的执行一些任务。\
接下来让我们来一步步学习 Go 语言指针。\
我们都知道，变量是一种使用方便的占位符，用于引用计算机内存地址。\
Go 语言的取地址符是 &，放到一个变量前使用就会返回相应变量的内存地址。\
以下实例演示了变量在内存中地址：
~~~go
package main


import "fmt"


func main() {
   var a int = 10   


   fmt.Printf("变量的地址: %x\n", &a  )
}
~~~
执行以上代码输出结果为：
~~~
变量的地址: 20818a220
~~~
现在我们已经了解了什么是内存地址和如何去访问它。接下来我们将具体介绍指针。

引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。

引用传递指针参数传递到函数内，以下是交换函数 swap() 使用了引用传递：
~~~go
/* 定义交换值函数*/
func swap(x *int, y *int) {
   var temp int
   temp = *x    /* 保持 x 地址上的值 */
   *x = *y      /* 将 y 值赋给 x */
   *y = temp    /* 将 temp 值赋给 y */
}
~~~
以下我们通过使用引用传递来调用 swap() 函数：
~~~
package main


import "fmt"


func main() {
   /* 定义局部变量 */
   var a int = 100
   var b int= 200


   fmt.Printf("交换前，a 的值 : %d\n", a )
   fmt.Printf("交换前，b 的值 : %d\n", b )


   /* 调用 swap() 函数
   * &a 指向 a 指针，a 变量的地址
   * &b 指向 b 指针，b 变量的地址
   */
   swap(&a, &b)


   fmt.Printf("交换后，a 的值 : %d\n", a )
   fmt.Printf("交换后，b 的值 : %d\n", b )
}


func swap(x *int, y *int) {
   var temp int
   temp = *x    /* 保存 x 地址上的值 */
   *x = *y      /* 将 y 值赋给 x */
   *y = temp    /* 将 temp 值赋给 y */
}
~~~
以上代码执行结果为：\
交换前，a 的值 : 100\
交换前，b 的值 : 200\
交换后，a 的值 : 200\
交换后，b 的值 : 100
### defer
defer语句被用于预定对一个函数的调用。可以把这类被defer语句调用的函数称为延迟函数。
 
defer作用：\
● 释放占用的资源
● 捕捉处理异常
● 输出日志
 
结果\ 
如果一个函数中有多个defer语句，它们会以LIFO（后进先出）的顺序执行。
~~~go
func Demo(){
	defer fmt.Println("1")
	defer fmt.Println("2")
	defer fmt.Println("3")
	defer fmt.Println("4")
}
func main() {
	Demo()
}
4
3
2
1
~~~
#### recover错误拦截
运行时panic异常一旦被引发就会导致程序崩溃。
 
Go语言提供了专用于“拦截”运行时panic的内建函数“recover”。它可以是当前的程序从运行时panic的状态中恢复并重新获得流程控制权。
 
注意：recover只有在defer调用的函数中有效。
~~~go
func recover interface{}
~~~
~~~go
package main

import "fmt"

func Demo(i int) {
	//定义10个元素的数组
	var arr [10]int
	//错误拦截要在产生错误前设置
	defer func() {
		//设置recover拦截错误信息
		err := recover()
		//产生panic异常  打印错误信息
		if err != nil {
			fmt.Println(err)
		}
	}()
	//根据函数参数为数组元素赋值
	//如果i的值超过数组下标 会报错误：数组下标越界
	arr[i] = 10

}

func main() {
	Demo(10)
	//产生错误后 程序继续
	fmt.Println("程序继续执行...")
}
~~~
输出
~~~
runtime error: index out of range
程序继续执行...
~~~
### slice和map
slice

Go 语言切片是对数组的抽象。

Go 数组的长度不可改变，在特定场景中这样的集合就不太适用，Go中提供了一种灵活，功能强悍的内置类型切片("动态数组"),与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。

#### 定义切片

你可以声明一个未指定大小的数组来定义切片：
~~~go
var identifier []type
~~~
切片不需要说明长度。

或使用make()函数来创建切片:
~~~go
var slice1 []type = make([]type, len)
~~~

也可以简写为
~~~go
slice1 := make([]type, len)
~~~
也可以指定容量，其中capacity为可选参数。
~~~go
make([]T, length, capacity)
~~~
这里 len 是数组的长度并且也是切片的初始长度。

#### 切片初始化
~~~go
s :=[] int {1,2,3 }
~~~
直接初始化切片，[]表示是切片类型，{1,2,3}初始化值依次是1,2,3.其cap=len=3
~~~go
s := arr[:]
~~~
初始化切片s,是数组arr的引用
~~~go
s := arr[startIndex:endIndex]
~~~
将arr中从下标startIndex到endIndex-1 下的元素创建为一个新的切片
~~~go
s := arr[startIndex:]
~~~
缺省endIndex时将表示一直到arr的最后一个元素
~~~go
s := arr[:endIndex]
~~~
缺省startIndex时将表示从arr的第一个元素开始
~~~go
s1 := s[startIndex:endIndex]
~~~
通过切片s初始化切片s1
~~~go
s :=make([]int,len,cap)
~~~
通过内置函数make()初始化切片s,[]int 标识为其元素类型为int的切片
#### len() 和 cap() 函数
切片是可索引的，并且可以由 len() 方法获取长度。\
切片提供了计算容量的方法 cap() 可以测量切片最长可以达到多少。\
以下为具体实例：
~~~go
package main


import "fmt"


func main() {
   var numbers = make([]int,3,5)


   printSlice(numbers)
}


func printSlice(x []int){
   fmt.Printf("len=%d cap=%d slice=%v\n",len(x),cap(x),x)
}
~~~
以上实例运行输出结果为:\
len=3 cap=5 slice=[0 0 0]
#### 空(nil)切片
一个切片在未初始化之前默认为 nil，长度为 0，实例如下：
~~~go
package main


import "fmt"


func main() {
   var numbers []int


   printSlice(numbers)


   if(numbers == nil){
      fmt.Printf("切片是空的")
   }
}


func printSlice(x []int){
   fmt.Printf("len=%d cap=%d slice=%v\n",len(x),cap(x),x)
}
~~~
以上实例运行输出结果为:\
len=0 cap=0 slice=[]\
切片是空的
#### 切片截取
可以通过设置下限及上限来设置截取切片[lower-bound:upper-bound]，实例如下：
~~~go
package main


import "fmt"


func main() {
   /* 创建切片 */
   numbers := []int{0,1,2,3,4,5,6,7,8}   
   printSlice(numbers)


   /* 打印原始切片 */
   fmt.Println("numbers ==", numbers)


   /* 打印子切片从索引1(包含) 到索引4(不包含)*/
   fmt.Println("numbers[1:4] ==", numbers[1:4])


   /* 默认下限为 0*/
   fmt.Println("numbers[:3] ==", numbers[:3])


   /* 默认上限为 len(s)*/
   fmt.Println("numbers[4:] ==", numbers[4:])


   numbers1 := make([]int,0,5)
   printSlice(numbers1)


   /* 打印子切片从索引  0(包含) 到索引 2(不包含) */
   number2 := numbers[:2]
   printSlice(number2)


   /* 打印子切片从索引 2(包含) 到索引 5(不包含) */
   number3 := numbers[2:5]
   printSlice(number3)


}


func printSlice(x []int){
   fmt.Printf("len=%d cap=%d slice=%v\n",len(x),cap(x),x)
}
~~~
执行以上代码输出结果为：
![1]({{site.baseurl}}/img-post/g-13.png)
#### append() 和 copy() 函数
如果想增加切片的容量，我们必须创建一个新的更大的切片并把原分片的内容都拷贝过来。\
下面的代码描述了从拷贝切片的 copy 方法和向切片追加新元素的 append 方法。
~~~go
package main


import "fmt"


func main() {
   var numbers []int
   printSlice(numbers)


   /* 允许追加空切片 */
   numbers = append(numbers, 0)
   printSlice(numbers)


   /* 向切片添加一个元素 */
   numbers = append(numbers, 1)
   printSlice(numbers)


   /* 同时添加多个元素 */
   numbers = append(numbers, 2,3,4)
   printSlice(numbers)


   /* 创建切片 numbers1 是之前切片的两倍容量*/
   numbers1 := make([]int, len(numbers), (cap(numbers))*2)


   /* 拷贝 numbers 的内容到 numbers1 */
   copy(numbers1,numbers)
   printSlice(numbers1)   
}


func printSlice(x []int){
   fmt.Printf("len=%d cap=%d slice=%v\n",len(x),cap(x),x)
}
~~~
以上代码执行输出结果为：
![1]({{site.baseurl}}/img-post/g-14.png)
#### map
map和slice类似，只不过是数据结构不同，下面是map的一些声明方式。
~~~go
package main
import (
    "fmt"
)

func main() {
    //第一种声明
    var test1 map[string]string
    //在使用map前，需要先make，make的作用就是给map分配数据空间
    test1 = make(map[string]string, 10) 
    test1["one"] = "php"
    test1["two"] = "golang"
    test1["three"] = "java"
    fmt.Println(test1) //map[two:golang three:java one:php]


    //第二种声明
    test2 := make(map[string]string)
    test2["one"] = "php"
    test2["two"] = "golang"
    test2["three"] = "java"
    fmt.Println(test2) //map[one:php two:golang three:java]

    //第三种声明
    test3 := map[string]string{
        "one" : "php",
        "two" : "golang",
        "three" : "java",
    }
    fmt.Println(test3) //map[one:php two:golang three:java]


    
    language := make(map[string]map[string]string)
    language["php"] = make(map[string]string, 2)
    language["php"]["id"] = "1"
    language["php"]["desc"] = "php是世界上最美的语言"
    language["golang"] = make(map[string]string, 2)
    language["golang"]["id"] = "2"
    language["golang"]["desc"] = "golang抗并发非常good"
    
    fmt.Println(language) //map[php:map[id:1 desc:php是世界上最美的语言] golang:map[id:2 desc:golang抗并发非常good]]


    //增删改查
    // val, key := language["php"]  //查找是否有php这个子元素
    // if key {
    //     fmt.Printf("%v", val)
    // } else {
    //     fmt.Printf("no");
    // }

    //language["php"]["id"] = "3" //修改了php子元素的id值
    //language["php"]["nickname"] = "啪啪啪" //增加php元素里的nickname值
    //delete(language, "php")  //删除了php子元素
    fmt.Println(language)
}
~~~
输出结果：
![1]({{site.baseurl}}/img-post/g-15.png)
## 五、Golang高阶
