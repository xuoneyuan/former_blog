---
layout:     post
title:      Apache Shiro 认证绕过漏洞(CVE-2020-1957)
subtitle:   
date:       2123-7-23
author:     xuoneyuan
header-img: 
catalog: 	  true
tags:
    - 漏洞复现
---
### 前言
这次花的时间比较多，主要是自己Java功底不太好，所以花了一些时间去学shiro以及IDEA的一些配置，当然最后也没得出什么高论，只能说学到了一点皮毛
### 漏洞分析
#### shiro介绍
Apache Shiro是一个强大且易用的Java安全框架,执行身份验证、授权、密码和会话管理。使用Shiro的易于理解的API,可以快速、轻松地获得任何应用程序,从最小的移动应用程序到最大的网络和企业应用程序。内置了可以连接大量安全数据源（又名目录）的Realm，如LDAP、关系数据库（JDBC）、类似INI的文本配置资源以及属性文件等。
#### 漏洞描述
CVE-2020-1957，Spring Boot中使用 Apache Shiro 进行身份验证、权限控制时，可以精心构造恶意的URL，利用 Apache Shiro 和 Spring Boot 对URL的处理的差异化，可以绕过 Apache Shiro 对 Spring Boot 中的 Servlet 的权限控制，越权并实现未授权访问

Apache Shiro 1.5.2之前的版本，由于Shiro拦截器和requestURI的匹配流程与Web框架的拦截器的匹配流程有差异，攻击者构造一个特殊的http请求，可以绕过Shiro的认证，未授权访问敏感路径。\
此漏洞有两种攻击方式，第一种攻击方式适用于Shiro < 1.5.0版本，由于Shiro 1.5.0版本修复补丁考虑不全面，导致补丁绕过，出现了第二种攻击方式，适用于Shiro < 1.5.2版本
#### 漏洞影响
Apache Shiro < 1.5.2
#### 环境搭建
[https://github.com/lenve/javaboy-code-samples/tree/master/shiro/shiro-basic](https://github.com/lenve/javaboy-code-samples/tree/master/shiro/shiro-basic)

修改shiro版本
![1]({{site.baseurl}}/img-post/shiro-6.png)
修改ShiroConfig配置文件，添加authc拦截器的拦截正则
![1]({{site.baseurl}}/img-post/shiro-7.png)
修改路由控制器方法
![1]({{site.baseurl}}/img-post/shiro-2.png)
run
![1]({{site.baseurl}}/img-post/shiro-1.png)
登录url：localhost:8080/login
![1]({{site.baseurl}}/img-post/shiro-3.png)
访问localhost:8080/hello/1，发现还是返回login界面，在后面加一/，即访问localhost:8080/hello/1,发现绕过成功
![1]({{site.baseurl}}/img-post/shiro-4.png)
#### 动态分析
首先在PathMatchingFilterChainResolver.class#getChain处下断点，进行调试

![1]({{site.baseurl}}/img-post/shiro-5.png)

我们单步步入getPathWithinApplication(request)，在WebUtils#getPathWithinApplication()中，参数为ServletRequest对象，获取到上下文信息后，再用getRequestUri()获取具体的url

![1]({{site.baseurl}}/img-post/shiro-8.png)

![1]({{site.baseurl}}/img-post/shiro-9.png)

### 漏洞修复
#### 1.5.0版本修复
1.5.0版本修复源自tomsun28提交的PR代码，代码修复位置为pathsMatch:125, PathMatchingFilter (org.apache.shiro.web.filter)，该修复方式是通过判断requestURI是否以/为结尾，如果以/结尾的话，则去掉尾部的/符号在与URL表达式进行比较。\
也就是当requestURI为/hello/1/等以/为结尾的URI的时候，都会被清除最后的/号，再进行URL路径匹配

![1]({{site.baseurl}}/img-post/shiro-11.png)

![1]({{site.baseurl}}/img-post/shiro-12.png)

#### ≤1.5.1版本绕过
在1.5.1版本中，添加/还是会直接跳转到登录\
绕过payload，/fdsf;/../hello/1，成功绕过\
问题同样可以定位到getChain函数中对于requestURI的获取中,this.getPathWithinApplication(request)获取的requestURI为/fdsf，而不是我们输入的/fdsf;/../hello/1，从而导致后面的URI路径模式匹配返回False，从而再次绕过了shiro拦截器\
getPathWithinApplication函数中会调用WebUtils (org.apache.shiro.web.util)中的getRequestUri函数获取RequestUri
~~~
public static String getRequestUri(HttpServletRequest request) {
        String uri = (String)request.getAttribute("javax.servlet.include.request_uri");
        if (uri == null) {
            uri = request.getRequestURI();
        }
        return normalize(decodeAndCleanUriString(request, uri));
    }
~~~
RequestUri函数中最终调用decodeAndCleanUriString函数对URI进行清洗
~~~
private static String decodeAndCleanUriString(HttpServletRequest request, String uri) {
      uri = decodeRequestString(request, uri);
      int semicolonIndex = uri.indexOf(59);//获取;号的位置
      return semicolonIndex != -1 ? uri.substring(0, semicolonIndex) : uri;
  }
~~~
#### 1.5.2版本修复
1.5.2版本中对其进行了修复，获取requestURI的方式从request.getRequestUri直接获取的方式更改为获取request的ContextPath，ServletPath，PathInfo，然后再重新拼接而成
输入的/fdsf;/../hello/1/，将会被拼接为//hello/1/1再进行URI路径匹配，则无法绕过拦截器

![1]({{site.baseurl}}/img-post/shiro-13.png)
